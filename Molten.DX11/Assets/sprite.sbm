<material>
	<name>sprite-texture</name>
	<description>The default material for rendering sprites in a SpriteBatch with a texture</description>
	<pass>
		<name>main</name>
		<iterations>1</iterations>
		<vertex>VS</vertex>
		<geometry>GS</geometry>
		<pixel>PS</pixel>
	</pass>
</material>

<material>
	<name>sprite-no-texture</name>
	<description>The default material for rendering sprites in a SpriteBatch with no texture.</description>
	<pass>
		<name>main</name>
		<iterations>1</iterations>
		<vertex>VS</vertex>
		<geometry>GS</geometry>
		<pixel>PS_NoTexture</pixel>
	</pass>
</material>

<material>
  <name>line</name>
  <description>The default material for rendering un-textured lines with 1 point per line.</description>
  <pass>
    <name>main</name>
    <iterations>1</iterations>
    <vertex>VS_Line</vertex>
    <geometry>GS_Line</geometry>
    <pixel>PS_NoTexture</pixel>
  </pass>
</material>

<material>
  <name>circle</name>
  <description>The default material for rendering an un-textured circle from a single point.</description>
  <pass>
    <name>main</name>
    <iterations>1</iterations>
    <vertex>VS_Circle</vertex>
    <geometry>GS_Circle</geometry>
    <pixel>PS_NoTexture</pixel>
  </pass>
</material>

<material>
  <name>triangle</name>
  <description>The default material for rendering an un-textured triangle from a single point.</description>
  <pass>
    <name>main</name>
    <iterations>1</iterations>
    <vertex>VS_Tri</vertex>
    <geometry>GS_Tri</geometry>
    <pixel>PS_NoTexture</pixel>
  </pass>
</material>

struct VS_GS
{
	float2 pos : POSITION0;
	float2 size : POSITION1;
	float2 origin : POSITION2;
	float4 uv : POSITION3;
	float rotation : POSITION4;
	float4 col : COLOR;
};

struct PS_IN
{
	float4 pos : SV_POSITION;
	float4 col : COLOR;
	float2 uv : TEXCOORD;
};

Texture2D albedo;
SamplerState albedoSampler;

float4x4 worldViewProj;
float2 textureSize;

static float degToRad360 = 6.28319;

VS_GS VS(VS_GS input)
{
	input.uv.xz /= textureSize.x;
	input.uv.yw /= textureSize.y;

	//invert y axis.
	input.pos.y = -input.pos.y;

	// Invert Y origin
	input.origin.y = -input.origin.y;

	return input;
}

VS_GS VS_Line(VS_GS input)
{
	//invert y axis.
	input.pos.y = -input.pos.y;
	input.size.y = -input.size.y; // y position of 2nd line point.
	return input;
}

VS_GS VS_Circle(VS_GS input)
{
	//invert y axis.
	input.pos.y = -input.pos.y;
	return input;
}

VS_GS VS_Tri(VS_GS input)
{
	//invert y axis.
	input.pos.y = -input.pos.y;
  input.size.y = -input.size.y;
  input.origin.y = -input.origin.y;
	return input;
}

const static float2 spriteCorners[4] = {
	float2(0,-1),
	float2(0, 0),
	float2(1,-1),
	float2(1,0),
};

const static int2 uvTable[4] = {
	int2(0,3),
	int2(0,1),
	int2(2,3),
	int2(2,1),
};

float2x2 GetRotation(float angle)
{
	// Compute a 2x2 rotation matrix.
	float c = cos(angle);
	float s = sin(angle);

	return float2x2(c, -s, s, c);
}

[maxvertexcount(4)]
void GS(point VS_GS input[1], inout TriangleStream<PS_IN> spriteStream)
{
	PS_IN v;
	v.col = input[0].col;

	float2x2 rot = GetRotation(input[0].rotation);
	float2 origin = input[0].origin.xy;
	float2 pos = input[0].pos.xy;
	float2 size = input[0].size.xy;
	float4 uv = input[0].uv;
	float2 p;

	[unroll]
	for (int i = 0; i < 4; i++)
	{
		p = mul(size * (spriteCorners[i] - origin), rot);
		p += pos;
		v.pos = float4(p, 0, 1);
		v.pos = mul(v.pos, worldViewProj);
		v.uv.x = uv[uvTable[i].x];
		v.uv.y = uv[uvTable[i].y];
		spriteStream.Append(v);
	}
}

[maxvertexcount(4)]
void GS_Line(point VS_GS input[1], inout TriangleStream<PS_IN> spriteStream)
{
	PS_IN v;
  v.col = input[0].col;
  v.uv = float2(0,0);
  float2 p1 = input[0].pos;
  float2 p2 = input[0].size;
  float2 dir = p2 - p1;
  float2 normal = normalize(float2(-dir.y, dir.x));
  float thickness = input[0].rotation * 0.5;
  
  // Vertex p1 vertex 0 (v0)
  v.pos = float4(p1 - (thickness * normal), 0, 1);
  v.pos = mul(v.pos, worldViewProj);
  spriteStream.Append(v);
  
  // Vertex p1 vertex 1 (v1)
  v.pos = float4(p1 + (thickness * normal), 0, 1);
  v.pos = mul(v.pos, worldViewProj);
  spriteStream.Append(v);
  
  // Vertex p2 vertex 0 (v2)
  v.col = input[0].uv;
  v.pos = float4(p2 - (thickness * normal), 0, 1);
  v.pos = mul(v.pos, worldViewProj);
  spriteStream.Append(v);
  
  // Vertex p2 vertex 1 (v3)
  v.pos = float4(p2 + (thickness * normal), 0, 1);
  v.pos = mul(v.pos, worldViewProj);
  spriteStream.Append(v);
}

[maxvertexcount(66)]
void GS_Circle(point VS_GS input[1], inout TriangleStream<PS_IN> spriteStream)
{
  PS_IN v;
  // center vertex
  v.col = input[0].col;
  v.uv = float2(0,0);
  float4 center = float4(input[0].pos, 0, 1);
  
  float segs = input[0].rotation;
  float2 radius = input[0].size;
  float2 startEnd = input[0].origin;
  float range = startEnd.y - startEnd.x;
  float angleInc = degToRad360 / segs;
  float angle = startEnd.x;
  float remaining = range;
  
  float inc = 0;
  float doEdge = 0; // if 0, we place a center point for the strip to orient around.
  float vCount = (segs * 2) + 2;
  for (int i = 0; i < vCount; i++)
  {
	  v.pos = center + (doEdge * float4(sin(angle) * radius.x, cos(angle) * radius.y, 0, 0));
	  v.pos = mul(v.pos, worldViewProj);	  

      inc = min(angleInc, remaining);
	  angle += inc * doEdge;
      remaining -= inc * doEdge;
	  doEdge = 1 - doEdge;
	  spriteStream.Append(v);
  }
}

[maxvertexcount(3)]
void GS_Tri(point VS_GS input[1], inout TriangleStream<PS_IN> spriteStream)
{
	PS_IN v;
  v.col = input[0].col;
  v.uv = float2(0,0);
  
  // p1
  v.pos = mul(float4(input[0].pos, 0, 1), worldViewProj);
  spriteStream.Append(v);
  
  // p3
  v.pos = mul(float4(input[0].origin, 0, 1), worldViewProj);
  spriteStream.Append(v);
  
  // p2
  v.pos = mul(float4(input[0].size, 0, 1), worldViewProj);
  spriteStream.Append(v);
}

float4 PS( PS_IN input ) : SV_Target
{
	float4 col = albedo.Sample(albedoSampler, input.uv);
	return col * input.col;
}

float4 PS_NoTexture(PS_IN input) : SV_Target
{
	return input.col;
}
